Линейные массивы
~~~~~~~~~~~~~~~~

В повседневной и научной практике часто приходится встречаться с информацией, представленной в табличной форме. Например, таблица, содержащая среднемесячные значения тем­пературы, °С, за определенный год:

.. figure:: img/temper.png
	:align: center
	:scale: 100%

Такую таблицу называют *линейной*. Она представляет собой пос­ледовательность упорядоченных чисел. Если требуется какая-то ма­тематическая обработка этих данных, то для их обозначения обычно вводят индексную символику. Например, через :math:`T_1`, обозначается температура января (первого месяца), :math:`Т_5` — температура мая и т.д. В общем виде множество значений, содержащихся в таблице, обо­значается так:

.. math::

	\{ T_i \}, i = 1..12

Можно создать массив фамилий "S" учеников класса. Значением элемента массива будет фамилия ученика, а индексом - порядковый номер по списку. Пусть дан список фамилий учеников и их оценки: 

.. figure:: img/student.png
	:align: center
	:scale: 100%

С массивом связаны следующие его свойства: имя, тип, раз­мерность, размер.

**Формат описания массива:**

тип_элементов имя[константное выражение]

Так же как и таблица, массив представляет собой совокупность про­нумерованных однотипных значений, имеющих общее имя. Эле­менты массива обозначаются переменными с индексами. **Индексы** - это порядковые номера элементов (0, 1,...,5...). Индек­сы записывают в квадратных скобках после имени массива. Индексированные величины удобно использовать для записи их математической обработки.

Константное выражение определяет размер массива, т. е. числе элементов этого массива. Например, согласно описанию 

::

	int A[10]; 
	
объявлен массив с именем А, содержащий 10 элементов целого типа. Элементы массива обозначаются индексированными имена­ми. 

.. attention:: В Си нижнее значение индекса равно 0 

А[0], А[8], А[1], А[9] А[2], А[3], А[4], А[5], А[6], А[7]

Описание массива определяет, во-первых, размещение масси­ва в памяти, во-вторых, правила его дальнейшего употребления в программе. Последовательные элементы массива располагаются в последовательных ячейках памяти (A[0], A[1] и т.д.), причем значения индекса не должны выходить из диапазона 0..9. В качестве индекса может употребляться любое выражение соответствующе­го типа.

В Си нельзя определять произвольные диапазоны для индексов. Размер массива, указанный в описа­нии, всегда на единицу больше максимального значения ин­декса. Размер массива может явно не указываться, если при его объявлении производится инициализация значений элементов. 

Например: 

::

	int p[]={2, 4, б, 10, 1}; 
	
В этом случае создается массив из пяти элементов со следую­ щими значениями: р[0]=2, р[1]=4, р[2]=б, р[3]=10, р[4]=1 

В результате следующего объявления массива 

::

	int М[6]={5, 3, 2}; 
	
будет создан массив из шести элементов. Первые три элемента получат инициализированные значения. Значения остальных бу­дут либо неопределенными, либо равны нулю, если массив вне­шний или статический. Рассмотрим несколько примеров программ обработки одно­мерных массивов. Если известна зависимость, по которой изменяются значения элементов массива, то присвоение значений удобно проводить в операторах цикла c параметром или с условием.

**Пример 1**: Ввод с клавиатуры и вывод на экран одномерного массива из 5 элементов:

::

	#include <iostream>
	using namespace std;

	int main()
	{ 
	    //Описание массива
	    int A [5];
	    
	    //Ввод элементов массива
	    for (int i = 0; i < 5;i++)
	    { 
		cout<<"A["<<i<<"]=";
		cin>>A[i];
	    }
	    
	    //Вывод массива
	    for (int i=0 ;i<5;i++)
		cout<<"A["<<i<<"]="<<A[i]<<endl;
	    return 0;		
	}

**Пример 2**: Ввод с клавиатуры и вычисление среднего арифметического одномерного массива из n элементов (n - константа):

::

	#include <iostream>
	using namespace std;

	int main()
	{ 
	    const int n=5; //константа, задающая количество элементов массива
	    int A[n];  //Массив из n элементов
	    double SA; //Среднее арифметическое
	    int SUM=0;   //Сумма элементов массива
	    //Ввод элементов массива
	    for (int i = 0; i < 5;i++){ 
		cout<<"A["<<i<<"]=";		//Запрос элемента массива
		cin>>A[i];			//Считывание значения с клавиатуры
		SUM=SUM+A[i];			//Добавление считанного значения к сумме элементов
	    }
	    SA=SUM/double(n);			//вычисление среднего арифметического
	    					//для получения вещественного значения приводим значение n к типу double
	    cout<<SA<<endl;			
	}

Если известна зависимость, по которой изменяются значения элементов массива, то присвоение значений удобно проводить в операторах цикла c параметром или с условием. Например, присвоим значения элементам массива "y" по зависимости: y=sin(x), где x=Pi*i/180, 0<=i<=180.

::

	const double pi=3.14;
	double y[200];
	for (i=0;i<=180;i++){
		y[i]:=(pi*i)/180.0;
	}
  



Формат определения функции
""""""""""""""""""""""""""""""

Формат определения функции следующий: 

*тип* **имя_функции** *(спецификация_параметров) *
{
	**тело_ функции**
} 

*Тип функции* — это тип возвращаемого функцией результата. Если функция не возвращает никакого результата, то для нее ука­зывается тип **void**. 

*Имя функции* — идентификатор, задаваемый программистом или **main** для основной функции. 

*Спецификации параметров* — это либо «пусто», либо список имен формальных параметров функции с указанием типа для каждого из них. 

*Тело функции* — это либо составной оператор, либо блок. Признаком блока является наличие описаний программных объектов (пере­менных, массивов и т.д.), которые действуют в пределах этого блока. Блок, как и составной оператор, ограничивается фигурны­ми скобками. 

.. note::В Си действует правило: тело функции не может содержать в себе определения других функций. Иначе говоря, недопустимы внут­ренние функции. 

Из всякой функции возможно обращение к другим функциям, однако они всегда яв­ляются внешними по отношению к вызывающей. Оператором возврата из функции в точку ее вызова является опе­ратор **return**. Он может использоваться в функциях в двух формах: 

**return;** или **return выражение;**

В первом случае функция не возвращает никакого значения в ка­честве своего результата. Во втором случае результатом функции яв­ляется значение указанного выражения. Тип этого выражения дол­жен либо совпадать с типом функции, либо относиться к числу ти­пов, допускающих автоматическое преобразование к типу функции. Оператор **return** может в явном виде отсутствовать в теле фун­кции. В таком случае его присутствие подразумевается перед зак­рывающей тело функции фигурной скобкой. Такая подстановка производится компилятором. 

Формат обращения к функции (вызова функции) традици­онный: 

имя_функции(список_фактических_праметров) 

Обращение к функции — это выражение. В этом выражении круг­лые скобки играют роль знака операции, для которой функция и фактические параметры (аргументы) являются операндами. Приори­тет операции «скобки» самый высокий, поэтому вычис­ление функции в выражениях производится раньше других операций.

Между формальными и фактическими параметрами при вызо­ве функции должны соблюдаться правила соответствия *по после­довательности* и *по типам*. 

Фактический параметр — это выраже­ние того же типа, что и у соответствующего ему формального параметра. Необходимо строго следовать принципу соот­ветствия типов. 

.. attention:: Передача параметров при вызове функции происхо­дит только по значению. В Си допустимы только параметры-значения. Поэтому выполнение функции не может изменить значения переменных, указанных в качестве фактических параметров. 

Прототип функции 
"""""""""""""""""

Прототипом называется предварительное описание функции, в котором содержатся все необходимые сведения для правильного обращения к ней: имя и тип функции, типы формальных параметров. В прототипе имена формальных параметров указывать необязательно, хотя их указание не является ошибочным. 

Полное определение функции **МАХ ()** перед основной частью программы необязательно. Вот другой вариант программы, решающей ту же самую задачу.

*Листинг maxproto.cpp*:

.. figure:: img/maxproto.png
	:align: center
	:scale: 100%
	
Мож­но было написать и так, как в заголовке определения функции: int MAX(int x, int у); 

.. attention:: Точка с запятой в конце прототипа ставится обязательно! 

Можно было бы записать прототип и в теле основной функции наряду с описаниями других программных объектов в ней. В

**Пример Функции03**:

Написать функцию, выводящую на экране строку, состоящую из 80 звездочек.

*Листинг: line.cpp* 

.. figure:: img/line.png
	:align: center
	:scale: 100%

	
В данной программе приводится пример использования функции, которая не имеет параметров и не возвращает никаких значений в точку вызова.

Использование библиотечных функций 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Библиотечными назы­ ваются вспомогательные функции, хранящиеся в отдельных фай­лах. Стандартные библиотеки входят в стандартный комплект си­стемы программирования на Си/Си++. Кроме того, программист может создавать собственные библиотеки функций. Для использования стандартных функций не­ обходимо подключать к программе заголовочные файлы соответ­ ствующих библиотек. Делается это с помощью директивы препроцессора **#include** с указанием имени заголовочного файла. Например, **#include<stdio.h>**. Эти файлы содержат прототипы функций библиотеки. На стадии препроцессора происходит подстановка прототипов перед основной функцией, после чего компилятор в состоянии контро­лировать правильность обращения к функциям. Сами программы, реализующие функции, хранятся в форме объектного кода и под­ключаются к основной программе на стадии редактирования свя­ ей (при работе компоновщика). 

**Пример Функции04**:

Составить программу для вычисления площади выпуклого четырехугольника по де­картовым координатам(рис. Функции01).

.. figure:: img/quadrilateral.png
	:align: center
	:scale: 100%
	:alt: "Рис. Функции01"

**Математическая модель:**

Обозначим координаты вершин четырехугольника так: (х1,у1), (х2,у2), (хЗ, у3), (х4, у4). Площадь четырехугольника можно вычислить как сумму площадей двух треугольников. В свою очередь, площадь каж­ дого треугольника вычисляется по формуле Герона.

.. figure:: img/geron.png
	:align: center
	:scale: 100%
	
Аналогично вычисляются дли­ны других отрезков. Таким образом, для решения основной задачи — вычисления площади четырехугольника — тре­буется вспомогательный алгоритм вычисления площади треугольни­ка  для которого, в свою очередь, необходим вспомогательный алгоритм вычисления длины отрез­ка по координатам концов.

*Листинг quadr.cpp*

.. figure:: img/quadr.png
	:align: center
	:scale: 100%


В этой программе используются функции из трех стандартных библиотек с заголовочными файлами **iostream**, **math.h**

Служебное слово **typedef** представляет собой спецификатор типа, позволяющий определять синонимы для обозначения ти­пов. В результате в рассматриваемой программе вместо длинного слова **double** для обозначения того же самого типа можно упот­реблять одну букву **D**. Данное описание действует глобально и рас­пространяется как на основную, так и навспомогательные функ­ции.

.. code-block:: cpp

	typedef double D;
	
В функции Geron имеются обращения к функции **Line**, а в основной функции — обращение только к функции **Geron**. 

.. attention::Для компилятора важно, чтобы перед вызывающей функцией присутствовал или прототип, или оп­ределение вызываемой функции. 

Поэтому если из данной програм­мы убрать прототип функции Line, то ошибки не будет. Но если одновременно с этим поменять местами определения функций **Line** и **Geron**, то компилятор выдаст сообщение об ошибке.

**Пример Функции05 (самостоятельно)**:

Составить программу для вычисления площади выпуклого пятиугольника по де­картовым координатам(рис. Функции02).

.. figure:: img/quadrilateral1.png
	:align: center
	:scale: 100%
	:alt: "Рис. Функции01"

Для реализации данной задачи достаточно в программе предыдущего примера **добавить** ввод координат пятой точки и вычисление площади третьего треугольника с помощью функций **Line** и **Geron**

