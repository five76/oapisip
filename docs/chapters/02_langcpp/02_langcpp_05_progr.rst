Линейные программы на Си/Си++
-----------------------------

Структура программы
~~~~~~~~~~~~~~~~~~~

Общая структура программы на Си++ следующая:

::

	#include <директива_препроцессора_1>
	#include <директива_препроцессора_2>
	``...``
	определение_функции_1
	определение_функции_2
	``...``
	определение_функции_n

	void main()
	{
		определения_объектов;
		исполняемые_операторы;
	}

Пример:

Дано: а, Ь, с — стороны треугольника. Вычислить S — площадь треугольника. По формуле Герона:

.. math::

	S = $\sqrt{2}$

Листинг "Площадь треугольника"

::

	#include<iostream>
	#include<cmath>
	#include<iomanip>
	
	using namespace std;
	
	int main()
	{
		// Описание переменных	
		float a,b,c,S,p;
		
		//Запрос данных
		cout<<"Введите значения сторон треугольника"<<endl;
		
		//Ввод данных
		cin>>a>>b>>c;
		
		//Вычисление полупериметра
		p=(a+b+c)/2;
		
		//Вычисление площади
		S=sqrt(p*(p-a)*(p-b)*(p-c));
		//---------Вывод результата в консоль-------------
		cout<<"Площадь треугольника: "<<fixed<<setprecision(2)<<S<<endl;
	}

**Комментарии:**
**main** - главная функция со стандартным именем.

**void** обозначает отсутствие какого-либо возвращаемого этой функцией результата, а пустые скобки — отсутствие у нее аргументов. 

Все, что следует после заголовка функции и заключе­но в фигурные скобки, можно назвать телом функции. Первая строка — объявление используемых переменных. Все они плаваю­щего типа **double**. Обратите внимание на то, что объявление пе­ременных заканчивается **точкой с запятой**.

Дальнейшая часть программы — исполняемые операторы. Понятие «оператор» в Си трактуется следующим образом: любое выражение, после которого стоит точка с запятой, вос­принимается компилятором как отдельный оператор. 

*Оператор определяет законченное действие на очередном шаге выполне­ния программы*.

С точки зрения данного выше определения следующая конст­рукция в программе является оператором:

**i++;**

Его называют *оператором-выражением*. Если вычисление выражения заканчивается присваиванием, то его можно назвать опера­тором присваивания. В рассматриваемой программе присутствуют два оператора присваивания: вычисления полупериметра (р) и вычисления площади треугольника (S).

В выражении для вычисления площади используется библио­течная функция **sqrt()** — квадратный корень.
Данная функция относится к библиотеке математических функ­ций. Для подключения этой библиотеки к нашей программе ис­пользуется директива препроцессора **#include <math.h>**.

Математические функции 
~~~~~~~~~~~~~~~~~~~~~~

.. figure:: 02_math_table.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Потоковый ввод-вывод в Си++
~~~~~~~~~~~~~~~~~~~~~~~~~~~

В Си++ имеются свои специфические средства ввода-вывода. Это библиотека классов, под­ключаемая к программе с помощью файла **iostream. h** . В этой библиотеке определены в качестве объектов стандартные символь­ные потоки со следующими именами:

* **cin** — стандартный поток **ввода** с клавиатуры;
* **cout** — стандартный поток **вывода** на экран.

**Ввод данных** интерпретируется как извлечение из потока cin и присваивание значений соответствующим переменным. В Си++ определена операция извлечения из стандартного потока, знак которой **>>**. 

Например, ввод значений в переменную **х** реализуется оператором

::

	cin>>x;

**Вывод данных** интерпретируется как помещение в стандартный поток **cout** выводимых значений. Выводиться могут тексты, за­ключенные в двойные кавычки, и значения выражений. Знак опе­рации помещения в поток **<<**. 

Примеры использования потоково­го вывода:

::
	
	cout<<a+b;
	соut<<"\nРезультат="<<y;
	cout<<"x=<<x<<" y="<<y<<" z=<<<<endl;

В выходном потоке можно использовать управляющие символы перед каждым элементом вывода нужно ста­вить знак операции **<<**. Элемент вывода **endl** является так называ­емым манипулятором, определяющим перевод курсора на новую строку (действует аналогично управляющему символу ``\n``).

В процессе потокового ввода-вывода происходит преобразо­вание из формы внешнего символьного представления во внут­ренний формат и обратно. Тип данных и необходимый формат определяются автоматически.

Стандартные форматы задаются специальными флагами форматирования, которые устанавлива­ются с помощью функции **setf()**












Подробнее про **setf()**
http://cppstudio.com/post/319/
https://intuit.ru/studies/courses/3479/721/lecture/25559











В Си++ имеется четыре базовых арифметических (число­вых) типа данных. Из них два целочисленных — **char**, **int** — и два плавающих (вещественных) — **float** и **double**. Также, в
программах можно использовать некоторые модификации этих ти­пов, описываемых с помощью служебных слов — модификаторов: 
* Модификаторы размера — **short** (короткий) и **long** (длинный)
* Модификатора знаков — **signed** (знаковый) и **unsigned** (беззнаковый). Знаковые модификаторы при­
меняются только к целым типам.
Ранее упоминалось,что тип величины связан с ее формой внутреннего представления, множеством принимаемых значений и множеством операций, применимых к этой величине.

**Схема типов данных**

.. figure:: 02_type_diag.png
       :scale: 100 %
       :align: center
       :alt: asda

**Арифметические типы данных Си++**

.. figure:: 02_type_table.png
       :scale: 100 %
       :align: center
       :alt: asda

Описание переменных
"""""""""""""""""""
Программа оперирует информацией, представленной в виде различных объектов и величин. Переменная – это символическое обозначение величины в программе. Значение   переменной (или величина, которую она обозначает) во время выполнения программы может изменяться.
С точки зрения архитектуры компьютера, переменная – это символическое обозначение ячейки оперативной памяти программы, в которой хранятся данные. Содержимое этой ячейки – это текущее значение переменной.
В языке Си++ прежде чем использовать переменную, ее необходимо оописать.
**Синтакис:**
*имя_типа список_переменных;*

**Примеры описаний:**

**char** symbol,сс;
**unsigned char** code;
**int** number,row;
**unsigned long** long_number;
**float** x,X,cc3;
**double** e,b4;
**long double** max_num;

Тип переменной определяет, какие возможные значения эта переменнаяможет принимать и какие операции можно выполнять над данной переменной. Тип переменной изменить нельзя.

**Инициализация переменных**
Вместе с описанием можно присвоить значение

::

	float pi=3.14159,с=1.23;
	unsigned int year=2000;

Константы
"""""""""

Запись целых констант
~~~~~~~~~~~~~~~~~~~~~

*Целые десятичные числа* начинающиеся не с нуля, например: 4, 356, —128.
*Целые восьмеричные числа*, запись которых начинается с нуля, например: 016, 077.
*Целые шестнадцатеричные числа*, запись которых начинается с символов Ох, например: OxlA, 0x253, OxFFFF.

Запись вещественных констант
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Если в записи числовой кон­станты присутствует десятичная точка (2.5) или экспоненциаль­ное расширение (1Е-8), то компилятор рассматривает ее как ве­щественное число и ставит ей в соответствие тип **double**.
Приме­ры вещественных констант: 44.0 3.14159 44Е0 1.5Е-4.

Использование суффиксов
~~~~~~~~~~~~~~~~~~~~~~~
Программист может явно задать тип константы, используя для этого суффиксы. Существуют три вида
суффиксов: F ( f ) - float ; U(u) - unsigned ; L ( l ) - long (для целых и вещественных констант). Допускается совместное использование суффиксов U и L в вариантах UL или LU.
Примеры: 3.14159F — константа типа floaf , под которую выделяется 4 байта памяти;
3,14L — константа типа long double, занимает 10 байт;
50000U — константа типа unsigned i n t , занимает 2 байта памяти (вместо четырех без суффикса);
0LU — константа типа unsigned long, занимает 4 байта;
24242424UL — константа типа unsigned long, занимает 4 байта.

Запись символьных и строковых констант
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Символьные констан­ты заключаются в апострофы. 
Например: ' А ' , ' а ' , ' 5 ' , ' + '. 
Стро­ковые константы, представляющие собой *символьные последова­тельности*, заключаются в двойные кавычки. Например: "rezult", "введите исходные данные".

**Управляющие символы** 
Их назначение — управление выводом на экран. Как известно, такие символы расположены в начальной части кодовой таблицы ASCII (коды от 0 до 31) и неимеют графического представления. В программе на Си они изоб­ражаются парой символов, первый из которых '\' . Вот некото­рые из управляющих символов:
**'\n'** — переход на новую строку;
**'\t'** — горизонтальная табуляция;
**'\а'** — подача звукового сигнала.

Именованные константы
~~~~~~~~~~~~~~~~~~~~~

Для их определения используется служебное слово **const** принято называть **квалификатором доступа**. Квалификатор const указывает на то, что данная величина не может изменяться в течение всего времени работы программы. В частно­сти, она не может располагаться в левой части оператора присва­ивания. Примеры описания константных переменных:

::
	const float pi=3.14159;
	const int iMIN=l, iMAX=1000;

Определение констант на стадии препроцессорной обработки
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Препроцессорная директива **#define**
:Директива **#define**: определяет идентификатор и последовательность символов, которой будет замещаться данный идентификатор при его обнаружении в тексте программы. Идентификатор так­же называется именем макроса, а процесс замещения называется подстановкой макроса. Стандар­тный вид директивы следующий:

::
	#define имя_макроса последовательность_символов

Например:
::
	#define iMIN l
	#define iMAX 1000
Тип констант явно не указывается и определяется по форме записи. В конце директивы **не ставится** *точка с запятой.*

Идентификаторы *iMAX* и *iMIN* не требуют описания внутри программы


Язык Си++ – это строго типизированный язык. Любая величина, используемая в программе, принадлежит к какому-либо типу. При любом использовании переменных в программе проверяется, применимо ли выражение или операция к типу переменной. Довольно часто смысл выражения зависит от типИнициализация переменных участвующих в нем переменных.
Например, если мы запишем x+y, где x – объявленная выше переменная, то переменная y должна быть одного из числовых типов.
Соответствие типов проверяется во время компиляции программы. Если компилятор обнаруживает несоответствие типа переменной и ее использования, он выдаст ошибку (или предупреждение). Однако во время выполнения программы типы не проверяются. Такой подход, с одной стороны, позволяет обнаружить и исправить большое количество ошибок на стадии компиляции, а, с другой стороны, не замедляет выполнения программы.
Переменной можно присвоить какое-либо значение с помощью операции присваивания. Присвоить – это значит установить текущее значение переменной. По-другому можно объяснить, что операция присваивания запоминает новое значение в ячейке памяти, которая обозначена переменной.
int x;      // объявить целую переменную x
int y;      // объявить целую переменную y
x = 0;      // присвоить x значение 0
y = x + 1;  // присвоить y значение x + 1, 
            // т.е. 1
x = 1;      // присвоить x значение 1
y = x + 1;  // присвоить y значение x + 1, 
            // теперь уже 2

Идентификаторы
""""""""""""""

Для символического обозначения величин, имен функций и т.п. используются имена или идентификаторы. Идентификаторы в языке Си++ – это последовательность знаков, начинающаяся с буквы или знака подчеркивания. В идентификаторах можно использовать заглавные и строчные латинские буквы, цифры и знак подчеркивания. Длина идентификаторов произвольная. 

**Примеры правильных идентификаторов:**
*abc*
*A12*
*NameOfPerson*
*BYTES_PER_WORD*

.. note:: abc и Abc – два разных идентификатора, т.е. заглавные и строчные буквы различаются. 

**Примеры неправильных идентификаторов:**

12X 
a-b

Служебные слова
"""""""""""""""
Служебные слова в Си++ — это идентификаторы, назначение которых однозначно определено в языке. Они не могут быть использованы как свобод­но выбираемые имена. Полный список служебных слов зависит от реализации языка, т. е. различается для разных компиляторов. Од­нако существует неизменное ядро, которое определено стандар­том Си++.

.. figure:: 02_system_words.png
       :scale: 100 %
       :align: center
       :alt: asda

Прямоугольниками отображены системные программы, а блоки с овальной формой обозначают файлы на входе и на выходе этих программ

.. figure:: 02_compile.png
       :scale: 100 %
       :align: center
       :alt: asda
       
1. С помощью текстового редактора формируется текст про­граммы и сохраняется в файле с расширением срр (example.срр).
2. Осуществляется этап *препроцессорной* обработки, содержа­ние которого определяется *директивами препроцессора*, рас­положенными перед заголовком программы (функции). В част­ности, по директиве **#include** препроцессор подключает к тек­сту программы заголовочные файлы (*.h) стандартных библио­тек.
3. Происходит *компиляция* текста программы на Си++. В ходе компиляции могут быть обнаружены синтаксические ошибки, которые должен исправить программист. В результате успешной компиляции получается объектный код программы в файле с рас­ширением **obj**. Например, **example.obj**.
4. Выполняется этап компоновки с помощью системной про­граммы Компоновщик (Linker). Этот этап еще называют редак­тированием связей. На данном этапе к программе подключаются библиотечные функции. В результате компоновки создается ис­полняемая программа в файле с расширением **ехе**. Например, **example.exe**.

:Компиля́тор: программа, переводящая текст, написанный на языке программирования, в набор машинных кодов
:Компиля́ция: трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду (абсолютный код, объектный модуль, иногда на язык ассемблера), выполняемая компилятором.


""""""""""""""""""""""""""""
#. Вычислительный алгоритм
#. Устройство, выполняющее примитивные операции
#. Формальные алгоритмы

Запись алгоритма на некотором языке представляет собой программу. Если программа написана на специальном алгоритмическом языке (например, на ПАСКАЛе или С++), то говорят об исходной программе. Программа, написанная на языке, который непосредственно понимает компьютер (как правило, это двоичные коды), называется машинной, или двоичной.

Основные способы записи алгоритмов
""""""""""""""""""""""""""""""""""

* вербальный  —  алгоритм  описывается  на  человеческом  языке;
* символьный — алгоритм описывается с помощью набора символов;
* графический — алгоритм описывается с помощью набора графических изображений.

При графическом представлении алгоритм изображается в виде последовательности связанных между собой функциональных блоков, каждый из которых соответствует выполнению одного или нескольких действий.
Такое графическое представление называется схемой алгоритма или блок-схемой. В блок-схеме каждому типу действий (вводу исходных данных, вычислению значений выражений, проверке условий, управлению повторением действий, окончанию обработки и т. п.) соответствует геометрическая фигура. Блоки соединяются линиями переходов, определяющими очередность выполнения действий.
**Основные блоки**

.. figure:: 02_compile.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Базовые алгоритмические структуры
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Алгоритмы можно представлять как некоторые структуры, состоящие из отдельных базовых элементов. Логическая структура любого алгоритма может быть представлена комбинацией трех базовых структур: следование, ветвление, цикл.
Характерной особенностью базовых структур является наличие в них одного входа и одного выхода.

Следование – действия выполняются строго в том порядке, в котором записаны. Образуется последовательностью действий, следующих одно за другим.

.. figure:: 01_if.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Ветвление
.........

:Ветвление: Форма организации действий, при которой в зависимости от справедливости проверяемого условия алгоритм может пойти по одной из двух возможных ветвей. Происходит выбор одного из альтернативных путей работы алгоритма. Каждый из путей ведет к общему выходу, так что работа алгоритма будет продолжаться независимо от того, какой путь будет выбран

1) **Неполная форма ветвления (если...то, if...then)**

.. figure:: 01_if.png
       :scale: 100 %
       :align: center
       :alt: asda

2) **Полная форма ветвления (если...то...иначе, if...then...else)**

.. figure:: 01_if_then.png
       :scale: 100 %
       :align: center
       :alt: asda
       
3) **Выбор (select case)**

.. figure:: 01_case.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Цикл
....

:Цикл: Форма организации действий, при которой одна и та же последовательность шагов алгоритма выполняется несколько раз или ни разу в зависимости от проверяемого условия

1) **Цикл с параметром (for)** – тело цикла выполняется для всех значений некоторой переменной (*параметра* цикла) в заданном диапазоне;

.. figure:: 01_for.png
       :scale: 100 %
       :align: center
       :alt: asda

2) **Цикл с предусловием (while)** – тело цикла выполняется до тех пор, пока выполняется условие;

.. figure:: 01_while.png
       :scale: 100 %
       :align: center
       :alt: asda

3) **Цикл с постусловием (repeat...until)** – тело цикла выполняется до тех пор, пока условие **не** выполняется;

.. figure:: 01_until.png
       :scale: 100 %
       :align: center
       :alt: asda
       
4) **Вложенные циклы**

Возможны случаи, когда внутри тела цикла необходимо повторять некоторую последовательность операторов, т. е. организовать внутренний цикл. Глубина вложения циклов (то есть количество вложенных друг в друга циклов) может быть различной. 

.. note:: При использовании такой структуры необходимо помнить, что параметр внутреннего цикла меняется быстрее параметра внешнего, при одном значении параметра внешнего цикла параметр внутреннего пробегает все свои возможные значения

.. figure:: 01_forin.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Данные и величины
"""""""""""""""""

В программировании изучаются методы программного управления работой компьютера, который выступает в качестве исполнителя. Компьютер работает с величинами — различными информационными объектами: числами, символами, кодами и др., поэтому алгоритмы, предназначенные для управления компьютером, называются алгоритмами работы с величинами.

:Данные: Совокупность величин, с которыми работает компьютер.

По отношению к программе различают исходные, окончательные (результаты) и промежуточные данные, которые получают в процессе вычислений.
Величина имеет три основных свойства: **имя, значение и тип**. На уровне команд процессора величина идентифицируется при помощи адреса ячейки памяти, в которой она хранится. В алгоритмах и языках программирования величины делятся на *константы и переменные* 
**Костанта** — неизменная величина, и в алгоритме она представляется собственным значением, например: 15, 34.7, k, true и т.д. 
**Переменная** может изменять свои значения в ходе выполнения программы и представляется символическим именем — **идентификатором**, например: X, S2, cod 15. 

Тип данных


:Тип данных: определяет множество значений, которые может принимать переменная и множество допустимых опе:раций

В любой язык входит минимально необходимый набор основных типов данных, к которому относятся: *целый, вещественный, логический и символьный* типы 

.. figure:: 01_data_type.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Примеры алгоритмов
""""""""""""""""""

Линейный вычислительный алгоритм
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Пример: Создать алгоритм деления обыкновенных дробей.

**Математическая модель:**

1. Числитель первой дроби умножить на знаменатель второй дроби.
2. Знаменатель первой дроби умножить на числитель второй дроби.
3. Записать дробь, числитель которой есть результат выполнения пункта 1, а знаменатель — результат выполнения пункта 2.

Алгебраическая форма:

.. figure:: 01_lin_form.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Блок - схема и текст на алгоритмическом языке (псевдокоде) выглядят следующим образом:

.. figure:: 01_lin_graph.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Данный алгоритм имеет линейную структуру. В нем все команды выполняются в строго однозначной последовательности, каждая по одному разу. Линейный алгоритм составляется из команд присваивания, ввода, вывода. При описании алгоритмов в блок-схемах типы, как правило,не указываются (но подразумеваются). 
В алгоритмах на АЯ для всех переменных типы указываются явно. Описание типов переменных производится сразу после заголовка алгоритма. В них используются следующие обозначения типов: цел — целый тип, вещ — вещественный тип, лит — символьный (литерный) тип, лог — логический тип. В алгоритме для деления дробей для всех переменных указан целый тип.

Ветвление
~~~~~~~~~
Составить алгоритм решения квадратного уравнения  ax\ :sup:`2`\ + bx + c = 0

**Математическая модель**

Решением в общем случае будут два корня x\ :sub:`1`, и x\ :sub:`2` , которые вычисляются по формуле:

.. figure:: 01_x12.png
       :scale: 100 %
       :align: center
       :alt: asda

.. figure:: 01_mm_kvur.png
       :scale: 100 %
       :align: center
       :alt: asda
       
**Блок-схема** алгоритма представлена на рисунке

.. figure:: 01_sh_kvur.png
       :scale: 100 %
       :align: center
       :alt: asda

**Псевдокод**

.. figure:: 01_ps_kvur.png
       :scale: 100 %
       :align: center
       :alt: asda

Циклы
~~~~~
Дано целое положительное число п. Требуется вычислить n! (n-факториал).

**Математическая модель**

.. figure:: 01_task_fact.png
       :scale: 100 %
       :align: center
       :alt: asda

:Таблица трассировки: Метод, используемый для тестирования алгоритмов, чтобы убедиться, что во время обработки вычислений не возникает логических ошибок. Таблица обычно имеет форму многоколоночной таблицы с несколькими строками; В каждом столбце показана переменная, а в каждой строке-каждое число, введенное в алгоритм, и последующие значения переменных. 

**Блок-схема** 
В алгоритме используются три переменные целого типа: *n* — аргумент; *i*—промежуточнаяпеременная; *F* — результат. Для проверки правильности алгоритма построена трассировочная таблица.

.. figure:: 01_sh_fact.png
       :scale: 100 %
       :align: center
       :alt: asda

**Псевдокод**

.. figure:: 01_ps_fact.png
       :scale: 100 %
       :align: center
       :alt: asda
       
В алгоритме использована структурная команда *цикл-пока*, или *цикл с предусловием*. Общий вид команды цикл-пока в блок-схемах и в алгоритмических языках следующий:

.. figure:: 01_cikl_ps.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Выполнение серии команд (**тела цикла**) повторяется, пока условие цикла истинно. Когда условие становится ложным, цикл заканчивает выполнение. Служебные слова **нц** и **кц** обозначают начало цикла и конец цикла соответственно.

Вспомогательные алгоритмы
~~~~~~~~~~~~~~~~~~~~~~~~~

:Вспомогательный алгоритм: Алгоритм, целиком используемый в составе другого алгоритма.

Составить алгоритм вычисления степенной функции с целым показателем у = х\ :sup:`k`\ , где к — целое число, не равное 0

**Математическая модель**

.. figure:: 01_task_va.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Для данной задачи в качестве подзадачи можно рассматривать возведение числа в целую положительную степень.
Основной алгоритм будет выглядеть следующим образом:

.. figure:: 01_ps_va1.png
       :scale: 100 %
       :align: center
       :alt: asda
       
Дважды используется команда обращения к вспомогательному алгоритму с именем СТЕПЕНЬ. Это алгоритм возведения вещественного основания в целую положительную степень путем его многократного перемножения. Величины, стоящие в скобках в команде обращения к вспомогательному алгоритму, называются фактическими параметрами.
Вспомогательные алгоритмы оформляются в виде процедур. Процедура СТЕПЕНЬ будет выглядеть так:

.. figure:: 01_ps_va2.png
       :scale: 100 %
       :align: center
       :alt: asda
       
а и k — формальные параметры-аргументы, z — параметр-результат.
Между формальными и фактическими параметрами процедуры должны выполняться следующие правила соответствия:
* по количеству (сколько формальных, столько и фактических параметров);
* по последовательности (первому формальному соответствует первый фактический параметр, второму — второй и т.д.);
* по типам (типы соответствующих формальных и фактических параметров должны совпадать)

Обращение к процедуре инициирует следующие действия: 

1. Значения параметров-аргументов присваиваются соответствующим формальным параметрам.
2. Выполняется тело процедуры (команды внутри процедуры).
3. Значение результата передается соответствующему фактическому параметру, и происходит переход к выполнению следующей команды основного алгоритма.

Использование процедур позволяет строить сложные алгоритмы методом *последовательной детализации*

       

asd :math:`a^2 + b^2 = c^2`

.. math::

   (a + b)^2 = a^2 + 2ab + b^2

   \frac{3}{4} 

.. sourcecode:: ipython3




Продолжение следует...


